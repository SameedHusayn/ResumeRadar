{
  "name": "ResumeRadar",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "simple": false,
        "filters": {
          "q": "has:attachment"
        },
        "options": {
          "downloadAttachments": true
        }
      },
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.2,
      "position": [
        220,
        40
      ],
      "id": "049242f2-4300-462a-9aa0-4b02dfde99c1",
      "name": "Gmail Trigger",
      "credentials": {
        "gmailOAuth2": {
          "id": "u8SdDakudI0DsN99",
          "name": "Gmail account"
        }
      }
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appzbBhAyKeU2danJ",
          "mode": "list",
          "cachedResultName": "ResumeRadar",
          "cachedResultUrl": "https://airtable.com/appzbBhAyKeU2danJ"
        },
        "table": {
          "__rl": true,
          "value": "tblnk2uJSYm7R5ABB",
          "mode": "list",
          "cachedResultName": "Job Descriptions",
          "cachedResultUrl": "https://airtable.com/appzbBhAyKeU2danJ/tblnk2uJSYm7R5ABB"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        440,
        160
      ],
      "id": "c610f1ed-df34-4bec-a308-ffa68b1eda74",
      "name": "Airtable",
      "credentials": {
        "airtableTokenApi": {
          "id": "O4DgdwO5EDlt3Eft",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "66b8762f-c4ee-46c4-b2e5-a9e78ffccebd",
              "leftValue": "={{ $json.matchFound }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        880,
        160
      ],
      "id": "2873ae38-0c44-4493-a604-1088e768ec63",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// ---------- config ----------\nconst MIN_SCORE = 0.60; // raise/lower to be stricter/looser\n// ----------------------------\n\n// Build job list from Airtable items\nconst jobListings = [];\nif (Array.isArray(items)) {\n  for (const item of items) {\n    if (item?.json) {\n      jobListings.push({\n        id:          item.json.id || '',\n        title:       item.json[\"Job Title\"] || '',\n        jobCode:     item.json[\"Job Code\"] || '',\n        description: item.json[\"Description\"] || '',\n        skills:      item.json[\"Skills Required\"] || '',\n        experience:  item.json[\"Experience Required\"] || item.json[\"Experience Required (Years)\"] || '',\n        location:    item.json[\"Location\"] || ''\n      });\n    }\n  }\n}\n\n// Email subject from Gmail Trigger (Option A: Simplify OFF)\nconst emailNode = $node[\"Gmail Trigger\"];\nconst email = emailNode?.json || {};\nlet subject = email.subject || email.Subject || '';\n\nif (!subject && items?.[0]?.json) {\n  subject = items[0].json.subject || items[0].json.Subject || '';\n}\n\nfunction extractJobTitle(subj) {\n  const lower = (subj || '').toLowerCase();\n  const patterns = [\n    /application (?:for|to) (.*?)(?:position|role|job)?$/i,\n    /(?:applying|apply) (?:for|to) (?:the )?(.*?)(?:position|role|job)?$/i,\n    /interested in (?:the )?(.*?)(?:position|role|job)/i,\n    /regarding (?:the )?(.*?)(?:position|role|job)/i,\n    /^(.*?)(?:position|job|role|application)$/i,\n  ];\n  for (const p of patterns) {\n    const m = lower.match(p);\n    if (m?.[1]?.trim()?.length > 3) return m[1].trim();\n  }\n  const capRe = /([A-Z][a-z]+(?: [A-Z][a-z]+)+)/g;\n  let best = '', m;\n  while ((m = capRe.exec(subj || '')) !== null) if (m[0].length > best.length) best = m[0];\n  if (best.length > 5) return best.toLowerCase();\n  return lower\n    .replace(/application for|applying for|regarding|re:|job application|position|role|job|application|interest in/g, '')\n    .replace(/^for the |for a |for |the |a /g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n// ---------- NEW similarity ----------\nconst STOP = new Set(['the','a','an','and','for','to','of','role','position','job','senior','jr','junior','lead','manager','developer','engineer']);\nconst PHRASE_REPL = [\n  ['machine learning','ai'],\n  ['artificial intelligence','ai'],\n  ['quality assurance','qa'],\n  ['full stack','fullstack'],\n  ['front end','frontend'],\n  ['back end','backend'],\n];\nconst TOKEN_MAP = { // single-token synonyms\n  ml: 'ai',\n  sdet: 'qa',\n  testing: 'qa',\n  test: 'qa',\n  sre: 'devops',\n};\n\nfunction normalizeTitle(s = '') {\n  s = s.toLowerCase();\n  for (const [a,b] of PHRASE_REPL) s = s.replace(new RegExp(a, 'g'), b);\n  s = s.replace(/[\\/,()\\-]/g, ' ');\n  s = s.replace(/\\s+/g, ' ').trim();\n  return s;\n}\n\nfunction canonicalTokens(s = '') {\n  const t = normalizeTitle(s).split(' ').filter(Boolean);\n  const out = [];\n  for (const tok of t) {\n    if (STOP.has(tok)) continue;\n    out.push(TOKEN_MAP[tok] || tok);\n  }\n  // dedupe, preserve order\n  return Array.from(new Set(out));\n}\n\nfunction jaccard(a, b) {\n  const A = new Set(a), B = new Set(b);\n  if (A.size === 0 && B.size === 0) return 1;\n  const inter = new Set([...A].filter(x => B.has(x))).size;\n  const uni = new Set([...A, ...B]).size;\n  return uni ? inter / uni : 0;\n}\n\nfunction lev(a, b) {\n  a = normalizeTitle(a); b = normalizeTitle(b);\n  if (!a && !b) return 1;\n  const T = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));\n  for (let i = 0; i <= a.length; i++) T[0][i] = i;\n  for (let j = 0; j <= b.length; j++) T[j][0] = j;\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      T[j][i] = Math.min(T[j][i - 1] + 1, T[j - 1][i] + 1, T[j - 1][i - 1] + cost);\n    }\n  }\n  const d = T[b.length][a.length];\n  const maxLen = Math.max(a.length, b.length) || 1;\n  return 1 - d / maxLen;\n}\n\n// final score = 70% token match + 30% string similarity\nfunction smartSim(s1, s2) {\n  const jac = jaccard(canonicalTokens(s1), canonicalTokens(s2));\n  const levSim = lev(s1, s2);\n  return 0.7 * jac + 0.3 * levSim;\n}\n// ------------------------------------\n\nconst jobKeywords = extractJobTitle(subject);\n\n// guard: no keywords\nif (!jobKeywords) {\n  return [{\n    json: {\n      subject,\n      extractedJobTitle: jobKeywords,\n      matchFound: false,\n      reason: \"No extractable job title from subject\"\n    },\n  }];\n}\n\n// find best match using smartSim\nlet best = null, bestScore = 0;\nfor (const j of jobListings) {\n  const s = smartSim(jobKeywords, j.title);\n  if (s > bestScore) { best = j; bestScore = s; }\n}\n\n// Return the match\nif (best && bestScore >= MIN_SCORE) {\n  return [{\n    json: {\n      subject,\n      extractedJobTitle: jobKeywords,\n      matchFound: true,\n      jobMatch: {\n        id: best.id,\n        title: best.title,\n        code: best.jobCode,\n        description: best.description,\n        skills: best.skills,\n        experience: best.experience,\n        location: best.location,\n        confidence: bestScore\n      }\n    },\n  }];\n}\n\nreturn [{\n  json: {\n    subject,\n    extractedJobTitle: jobKeywords,\n    matchFound: false,\n    reason: best\n      ? `Low confidence (${bestScore.toFixed(2)}) vs threshold ${MIN_SCORE}`\n      : 'No jobs in list'\n  },\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        160
      ],
      "id": "424f557a-1bab-4116-ad34-2f03251f44d9",
      "name": "EmailMatcher"
    },
    {
      "parameters": {
        "jsCode": "// PromptBuilder â€” builds the LLM prompt + carries email body & job meta\n\nconst m   = items[0]?.json ?? {};\nconst job = m.jobMatch ?? {};\n\n// helpers\nfunction stripHtml(s = '') {\n  return String(s)\n    .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\nfunction firstStr(...vals) {\n  for (const v of vals) if (typeof v === 'string' && v.trim()) return v.trim();\n  return '';\n}\n\n// get Gmail payload (paired item first, then pinned/previous run as fallback)\nconst g1 = $item(0, 'Gmail Trigger')?.$json ?? {};\nconst g2 = (($items && $items('Gmail Trigger', 0)) || [])[0]?.json ?? {};\n\n// build email body: prefer any body already carried on the item, else read from Gmail\nlet emailBody = firstStr(\n  m.emailBody,\n  g1.text, g1.textPlain,\n  g1.html ? stripHtml(g1.html) : '',\n  g1.textHtml ? stripHtml(g1.textHtml) : '',\n  g1.textAsHtml ? stripHtml(g1.textAsHtml) : '',\n  g1.snippet,\n  g2.text, g2.textPlain,\n  g2.html ? stripHtml(g2.html) : '',\n  g2.textHtml ? stripHtml(g2.textHtml) : '',\n  g2.textAsHtml ? stripHtml(g2.textAsHtml) : '',\n  g2.snippet\n);\nemailBody = emailBody.slice(0, 5000); // keep prompt compact\n\n// subject: prefer the one already on the item (from EmailMatcher), else Gmail\nconst subject = firstStr(m.subject, g1.subject, g2.subject);\n\n// prompt\nconst prompt = `\nYou are a senior technical recruiter.\n\nTASKS\n1) Read the ATTACHED resume (primary source of truth).\n2) Consider the email subject & body for extra context.\n3) Evaluate fit against the JOB description.\n\nExtract ONLY from the resume (do NOT infer from email headers):\n- candidateName: full legal name as printed in the resume. If missing, return \"\".\n- candidatePhone: best reachable phone (normalize to E.164 if possible; else raw). If missing, return \"\".\n\nScoring:\n- score: integer 1â€“10 (10=excellent, 7â€“9=strong, 4â€“6=partial, 1â€“3=poor).\n- explanation: one concise sentence under 40 words.\n\nEMAIL\n- Subject: ${subject}\n- Body: ${emailBody}\n\nJOB\n- Title: ${job.title || \"\"}\n- Code: ${job.code || \"\"}\n- Description: ${job.description || \"\"}\n- Skills Required: ${job.skills || \"\"}\n- Experience Required: ${job.experience || \"\"}\n- Location: ${job.location || \"\"}\n\nReturn STRICT JSON only (no prose, no markdown):\n{\n  \"score\": <1-10>,\n  \"explanation\": \"<under 40 words>\",\n  \"candidateName\": \"<from resume or empty string>\",\n  \"candidatePhone\": \"<E.164 if possible else raw or empty string>\"\n}\n`.trim();\n\nreturn [{ json: { prompt, jobMeta: job } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        200
      ],
      "id": "a528ce65-eeb4-49c4-8c8d-bf152ea6f52a",
      "name": "PromptBuilder"
    },
    {
      "parameters": {
        "jsCode": "const matched = items.some(i => i.json?.matchFound === true || i.json?.jobMatch);\nif (!matched) return [];\n\n\n// Keep only real resume-ish attachments\nconst ALLOWED = new Set([\n  'application/pdf',\n]);\n\n    \n// --- helpers ---\nfunction headerPick(g, key) {\n  const v = g.headers?.[key] || g.headers?.[key.toLowerCase()];\n  return v ? String(v).replace(/^[A-Za-z-]+:\\s*/, '') : '';\n}\nfunction pickEmail(str) {\n  const m = String(str || '').match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n  return m ? m[0].toLowerCase() : '';\n}\nfunction pickName(str) {\n  // \"Display Name\" <email@domain>\n  const m = String(str || '').match(/^\"?([^\"<]+?)\"?\\s*<[^>]+>/);\n  return m ? m[1].trim() : '';\n}\nfunction extractSender(g) {\n  // 1) Preferred: rich shape\n  const v0 = g.from?.value?.[0];\n  const addr = v0?.address || '';\n  const nm   = v0?.name || '';\n\n  // 2) Text forms (rich shape has these too)\n  const fromText = typeof g.from?.text === 'string' ? g.from.text : '';\n  const replyTo  = headerPick(g, 'reply-to');\n  const fromHdr  = headerPick(g, 'from') || fromText;\n  const returnPath = headerPick(g, 'return-path');\n\n  // Decide email\n  const email = addr || pickEmail(fromHdr) || pickEmail(replyTo) || pickEmail(returnPath) || '';\n  // Decide name\n  let name = nm || pickName(fromHdr);\n  if (!name && email) name = email.split('@')[0];\n\n  return { email, name };\n}\n\nconst out = [];\nfor (const item of items) {\n  const g = item.json || {};\n  const { email: fromEmail, name: fromName } = extractSender(g);\n\n  // Prefer internalDate (epoch); else parse ISO \"date\"; else now\n  const when =\n    (g.internalDate ? Number(g.internalDate) : 0) ||\n    (g.date ? Date.parse(g.date) : 0) ||\n    Date.now();\n\n  if (!item.binary) continue;\n  for (const key of Object.keys(item.binary)) {\n    const bin = item.binary[key];\n    if (!bin?.data) continue;\n    if (ALLOWED.size && !ALLOWED.has(bin.mimeType)) continue;\n\n    out.push({\n      json: {\n        fileName: bin.fileName || 'resume',\n        mimeType: bin.mimeType || 'application/octet-stream',\n        fromEmail,\n        fromName,\n        internalDate: when,\n        subject: g.subject || headerPick(g, 'subject') || ''\n      },\n      binary: { data: bin } // Downstream nodes use Binary Property: \"data\"\n    });\n  }\n}\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1320,
        -160
      ],
      "id": "39fc01a4-5a9b-438e-9932-e4b82f47bb4c",
      "name": "ReadyAttachment",
      "alwaysOutputData": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1760,
        -20
      ],
      "id": "ee2d7f60-58be-475c-8d54-502f0bbf0aea",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "const inItems = items.map(i => i.json);\n\n// 1) file object from FileUpload\nconst fileBlock = inItems.find(o => o.file?.uri)?.file;\nif (!fileBlock?.uri) throw new Error('Missing Gemini file URI');\n\n// 2) prompt/meta from PromptBuilder\nconst metaBlock = inItems.find(o => typeof o.prompt === 'string') || {};\nconst jm = metaBlock.jobMeta || {};\n\n// 3) prefer the ORIGINAL attachment mimeType (from ReadyAttachment);\n//    fallback to the FileUpload's mimeType; final fallback to octet-stream.\nconst realMime =\n  (inItems.find(o => o.mimeType)?.mimeType) ||      // ReadyAttachment\n  fileBlock.mimeType ||                             // FileUpload (if correct)\n  'application/octet-stream';\n\nconst parts = [];\nif (metaBlock.prompt) parts.push({ text: metaBlock.prompt });\nif (metaBlock.emailBody) parts.push({ text: `\\nEMAIL BODY:\\n${metaBlock.emailBody}` });\n\nparts.push({\n  text:\n`JOB META:\nTitle: ${jm.title ?? ''}\nCode: ${jm.code ?? ''}\nDescription: ${jm.description ?? ''}\nSkills: ${jm.skills ?? ''}\nExperience: ${jm.experience ?? ''}\nLocation: ${jm.location ?? ''}`\n});\n\n// âœ… pass the real mime type here\nparts.push({\n  fileData: {\n    fileUri: fileBlock.uri,\n    mimeType: realMime\n  }\n});\n\nconst body = {\n  contents: [{ role: 'user', parts }],\n  generationConfig: {\n    temperature: 0.1,\n    responseMimeType: 'application/json',\n    responseSchema: {\n      type: 'object',\n      properties: {\n        score: { type: 'integer', minimum: 1, maximum: 10 },\n        explanation: { type: 'string' },\n        candidateName: { type: 'string' },\n        candidatePhone: { type: 'string' }\n      },\n      required: ['score','explanation']\n    },\n  },\n};\n\nreturn [{ json: { body } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1980,
        -20
      ],
      "id": "08d15341-fad1-41b4-8dd1-45c19ef66e19",
      "name": "PayloadBuilder"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/upload/v1beta/files?uploadType=media",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-goog-api-key",
              "value": "AIzaSyBkitZ9k1zdbEgtx4cagbenkVv9zezX2F0"
            },
            {
              "name": "Content-Type",
              "value": "={{ $json.mimeType || $binary.data.mimeType || 'application/octet-stream' }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1540,
        -20
      ],
      "id": "c18f2954-dced-4342-a0aa-66a81545f5ff",
      "name": "FileUpload"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "key",
              "value": "={{$env.GEMINI_API_KEY}}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{$json.body}}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2200,
        -20
      ],
      "id": "14be41de-3ef7-4258-952d-affe1c439341",
      "name": "ResponseGenerator"
    },
    {
      "parameters": {
        "jsCode": "// Input is the ONE merged item\nconst j = items[0].json;\n\n// Parse model JSON\nconst text = j?.candidates?.[0]?.content?.parts?.[0]?.text ?? '{}';\nlet data = {};\ntry { data = JSON.parse(text); } catch {}\n\nconst normPhone = s => s ? s.toString().trim().replace(/[^\\d+]/g,'') : '';\n\n// Build the exact columns we want for Sheets\nreturn [{\n  json: {\n    JobTitle: j.jobMeta?.title || j.jobMatch?.title || j.subject || '',\n    CandidateName: (data.candidateName || '').trim() || (j.fromName || ''),\n    CandidateEmail: j.fromEmail || '',\n    CandidatePhoneNumber: normPhone(data.candidatePhone || ''),\n    // prefer open link; fallback to direct or ID\n    ResumeLink: j.webViewLink || j.webContentLink || (j.id ? `https://drive.google.com/file/d/${j.id}/view?usp=drivesdk` : ''),\n    AIScore: data.score ?? null,\n    AIExplanation: data.explanation ?? ''\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        -100
      ],
      "id": "e0dd0699-059a-49ba-942d-58f10aaec4b7",
      "name": "ParseResponse"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1100,
        -170
      ],
      "id": "f0c3079a-8cda-4a2c-bfde-0fc3d61037bd",
      "name": "Merge1"
    },
    {
      "parameters": {
        "name": "={{\n  (function () {\n    const email = ($json.fromEmail || 'unknown').toLowerCase();\n    const user = email.split('@')[0].replace(/[^a-z0-9._-]+/g,'-').replace(/^-+|-+$/g,'');\n    const d = new Date(Number($json.internalDate) || Date.now());\n    const yyyy=d.getUTCFullYear(), mm=String(d.getUTCMonth()+1).padStart(2,'0'),\n          dd=String(d.getUTCDate()).padStart(2,'0'),\n          hh=String(d.getUTCHours()).padStart(2,'0'),\n          mi=String(d.getUTCMinutes()).padStart(2,'0'),\n          ss=String(d.getUTCSeconds()).padStart(2,'0');\n    const ext = (($json.fileName || '').split('.').pop()\n              || ($json.mimeType==='application/pdf'?'pdf':'bin')).toLowerCase();\n    return `${user || 'unknown'}__${yyyy}-${mm}-${dd}-${hh}${mi}${ss}.${ext}`;\n  })()\n}}\n",
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "value": "1nI3oQ_hfa8eEDJ2aThNT45T7SfJ5jGzd",
          "mode": "list",
          "cachedResultName": "ResumeRadar",
          "cachedResultUrl": "https://drive.google.com/drive/folders/1nI3oQ_hfa8eEDJ2aThNT45T7SfJ5jGzd"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        2200,
        -320
      ],
      "id": "03a33b24-68a2-4f5f-afc2-36ef1cbdb0f7",
      "name": "Google Drive",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "fFPZO0wX94Keroqy",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "numberInputs": 4,
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2420,
        -116
      ],
      "id": "2ef593bc-bd85-451b-91a4-e93c32739659",
      "name": "CombineData"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1OGWk5UJdb2XrTS-5k9R0Q44d8HpvhdQW3AtzqkdWffg",
          "mode": "list",
          "cachedResultName": "ResumeRadar - Applicants",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1OGWk5UJdb2XrTS-5k9R0Q44d8HpvhdQW3AtzqkdWffg/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1OGWk5UJdb2XrTS-5k9R0Q44d8HpvhdQW3AtzqkdWffg/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Job Title": "={{ $json.JobTitle }}",
            "Email": "={{ $json.CandidateEmail }}",
            "Resume": "={{ '=HYPERLINK(\"' + $json.ResumeLink + '\",\"Download\")' }}",
            "AI Explanation": "={{ $json.AIExplanation }}",
            "AI Score": "={{ $json.AIScore }}",
            "Candidate Name": "={{ $json.CandidateName }}",
            "Contact": "={{ $json.CandidatePhoneNumber }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "Job Title",
              "displayName": "Job Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Candidate Name",
              "displayName": "Candidate Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Email",
              "displayName": "Email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Contact",
              "displayName": "Contact",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Resume",
              "displayName": "Resume",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "AI Score",
              "displayName": "AI Score",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "AI Explanation",
              "displayName": "AI Explanation",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.6,
      "position": [
        2860,
        -95
      ],
      "id": "3cf0a49e-df9a-4cca-b245-a46838748e69",
      "name": "Google Sheets",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "G25jStA6MmWt8RXy",
          "name": "Google Sheets account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Gmail Trigger": {
      "main": [
        [
          {
            "node": "Airtable",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Airtable": {
      "main": [
        [
          {
            "node": "EmailMatcher",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          },
          {
            "node": "PromptBuilder",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "EmailMatcher": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PromptBuilder": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          },
          {
            "node": "CombineData",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "ReadyAttachment": {
      "main": [
        [
          {
            "node": "FileUpload",
            "type": "main",
            "index": 0
          },
          {
            "node": "Google Drive",
            "type": "main",
            "index": 0
          },
          {
            "node": "CombineData",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "PayloadBuilder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PayloadBuilder": {
      "main": [
        [
          {
            "node": "ResponseGenerator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FileUpload": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ResponseGenerator": {
      "main": [
        [
          {
            "node": "CombineData",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "ReadyAttachment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Drive": {
      "main": [
        [
          {
            "node": "CombineData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CombineData": {
      "main": [
        [
          {
            "node": "ParseResponse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ParseResponse": {
      "main": [
        [
          {
            "node": "Google Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "08d5c83a-92c7-4856-b51f-8c35523c31b4",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "241556d3cf444495f115cc4ed051381e5c047247800e2729fa805d67681495ea"
  },
  "id": "eRS0KpRKSwAZs7rW",
  "tags": []
}